---
title: 2022_06学习笔记
date: 2022/06/01 00:00
description:
categories: 知识卡片
---

# [为什么要建立必须赚钱的产品理念？](http://www.woshipm.com/pmd/728827.html)

> 建立必须赚钱的产品理念和你要收费是两码事

- 真实的需求更能打动用户

- 用户关注产品的时间有限，宏大的理念难以在有限的时间打动用户

- 用户不会为伪需求买单，有付费意愿是真伪需求的一个判断依据

> 可以这么说，一个不以盈利为坚定目标的产品，一开始眼里就不会有用户，很难获得成功，只有想从用户身上赚钱时，才会真心在产品上做到最好。
> 
> 所以，**技术至上的产品思维，恰好反映了产品经理的惰性，因为通过市场洞察找到一个“用户肯定会购买的理由”比解决技术问题更难，所以懒惰的产品经理更偏向于用“我很努力地解决技术问题”来掩饰自己的惰性。**

> **一个包含被购买的理由、包含被成功营销的可能性、包含每个分发渠道的合理利益、包含可被高效制造和贩卖的空间，再按照以上目标设计出具有用户价值的产品，才可以称为商品。**

> **商品思维的核心思想是提高效率，在整个生产、制造、传播、贩卖的链条里，都保持最高的效率**。

# 什么是单元测试的打桩（stub）

Mock 数据的一种方式，如果某些数据来自于其他模块/操作，可以直接拿到数据模拟进行测试。

# 动态 Import backend vs frontend

[Nest cannot export a component/module that is not a part of the currently processed module · Issue #1010 · nestjs/nest · GitHub](https://github.com/nestjs/nest/issues/1010#issuecomment-417649864)

>  They are very useful when it comes to the frontend world when you can dynamically import functionalities/modules/components, but in the backend, we don't have three-shaking, we don't care about the size of the final minified bundle, and we don't expose anything directly to the user.

在前端的世界里面动态 import 函数/模块/组件非常有用，但是在后端，我们不需要 tree-shaking，我们不关心最后打包出来的文件打下，我们不向用户直接暴露任何东西。

# ORM 实例

**ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是"对象-关系映射"（Object/Relational Mapping） 的缩写**
![](https://images.scar.site/20220613183726.png)

# Symbol、Map、Set

> [现代 Javascript 教程](https://zh.javascript.info/map-set)

`Symbol` 唯一的键名

`Map` 与普通对象 `Object` 的不同点：

- 任何键、对象都可以作为键。
- 有其他的便捷方法，如 `size` 属性。

`Set` —— 是一组唯一值的集合。

## 资料

* [ES6中Symbol的作用是什么 - web开发 - 亿速云](https://m.yisu.com/zixun/173057.html)

# Eating your own dog food/Dogfooding

内源测试/内部测试，公司自己内部使用自己的产品

# [How to write async await without try-catch blocks in Javascript](https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/)

async await 的优雅写法

# Proxy 学习

```javascript
let obj = { name: "scar" };
let proxy = new Proxy(obj, {
  get(target, key) {
    proxy.a = "test";
    return "我被代理了";
  },
});
console.log(obj.name);//scar,proxy 没有输出
console.log(proxy.name);//我被代理了
// change origin data
console.log(obj.a);//test
```

> 对 `proxy` 进行操作，如果在 `handler` 中存在相应的捕捉器，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理。 
> 
> -- 现代 Javascript 教程

* Proxy 只监控 Proxy 对象的改变，原对象改变不会被监控

* Proxy 改变了，原对象也会改变

* Proxy 在深度对象的性能比 defineProperty 高

# WebRTC

> 旨在建立一个互联网浏览器之间音视频和数据实时通信的平台

实时通信技术，包括其中各种技术细节。

## 协议

* NAT（网络 IP 转换协议），每个设备/每个路由一个私有 IP，NAT 做转发

* [Traversal Using Relays around NAT (TURN)](https://en.wikipedia.org/wiki/TURN

* [Session Traversal Utilities for NAT (STUN)](https://en.wikipedia.org/wiki/STUN)

# 