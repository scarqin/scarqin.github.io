{"meta":{"title":"秦一","subtitle":"","description":"","author":"秦一","url":"http://scar.site","root":"/"},"pages":[],"posts":[{"title":"为什么我的 gitignore 无效","slug":"为什么我的 gitignore 无效","date":"2021-04-13T00:20:22.408Z","updated":"2021-04-13T00:30:54.247Z","comments":true,"path":"为什么我的 gitignore 无效/","link":"","permalink":"http://scar.site/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84%20gitignore%20%E6%97%A0%E6%95%88/","excerpt":"","text":"问题背景 项目有一些开发时用的配置文件，需要用到所以不能删，但是却不想提交改动。 理所当然地想到将它加入 .gitignore 规则中，但是我的改动还是被 git 被捕捉到了，为啥呢？ gitignore - Specifies intentionally untracked files to ignore 官方文档给出了标准答案，原来 .gitignore 只对未跟踪的文件起作用！ 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次提交中有它们的记录。那么未跟踪文件就是指那些从没提交过的文件。 因为我之前已经使用提交过了，所以.gitignore也救不了我 。 那我现在已经覆水难收的情况下，想要忽略 index.scss 该怎么做？ 解决方案我与 git 的对话【我】：我的目的是在仓库里面保留 index.scss，但是要所有人忽略它的改动。你能做到吗？ 【git】：我做不到，我是个版本控制的仓库，我要为所有文件的版本负责，而不是你存储文件的中转站！但是你可以这样： 别让我管理你的 index.scss，踢出我的版本控制，存在自个儿的电脑里。 暂时只忽略你的文件改动，别人已加到版本库的文件改动，你可管不着。 让我们来看看根据 git 提供的思路，如何实践。 取消跟踪,删除远程文件（推荐）你要做的 先将 src/index.scss 加入 .gitignore 文件。 再执行以下命令：123git rm --cached src&#x2F;index.scss git add src&#x2F;index.scssgit commit -m &quot;ignore index.scss&quot; 在你的电脑进行以上操作后，index.scss 正式脱离了版本管理的管制。git rm --cached 会保留你本机的文件，但是会从版本库里面删除。 其他电脑要做的 git pull 将 index.scss 加回来 因为其他主机（您同事的电脑等等）在 git pull 你以上的改动时，index.scss 会被删除，所以 index.scss 需要加回来。 可以手动加回来，也可以使用构建工具初始化自动生成 index.scss 文件。 暂时忽略已跟踪文件的变更，不删除远程文件（不推荐）你要做的 git update-index –assume-unchanged src/index.scss 其他电脑要做的 git update-index –assume-unchanged src/index.scss git update-index 为一个单独文件创建暂存区，--assume-unchanged 通知 git 不要再监控这个文件的改动了。 合起来的意思是：我单独把你拎出来，暂时先跟踪你。因为命令只对当前工作区生效，同理其他主机也要进行同样的操作。 为什么推荐方案（1）不推荐方案（2）?方案（2）非常纯粹，一招鲜吃遍天。 但是它容易出错，如果某个同事忘记执行这条指令，将 index.scss 提交到了版本库，那么其他人都需要一起——重新执行命令，再次让版本库忽略 index.scss。 过来人告诉你，这方法真的不好维护。 使用方案（1），因为文件已经删了，且已经将其加入到了 .gitignore，后续的提交都不会跟踪这份新的 index.scss 文件。同事忘不忘记操作也只是影响他自己，而且只需一次操作，无后顾之忧。 资料 n͛i͛g͛h͛t͛i͛r͛e͛-git忽略已经被提交的文件 gitignore 解释 Git 使用札记（二）","categories":[],"tags":[]},{"title":"MutationObserver 是什么","slug":"MutationObserver 是什么","date":"2021-04-13T00:20:22.360Z","updated":"2021-04-13T00:20:22.362Z","comments":true,"path":"MutationObserver 是什么/","link":"","permalink":"http://scar.site/MutationObserver%20%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"MutationObserver 是什么MutationObserver API 让我们能监听 DOM 树变化，该 API 设计用来替换掉在 DOM 3 事件规范中引入的 Mutation events。 Mutation events 是同步触发的，每次变动都会触发一次调用。MutationObserver API 是异步触发的， DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。所以 MutationObserver 相比 Mutation events 性能要更高。 代码示例12345678910111213141516171819202122 // 某个需要被监控的 dom 元素。var targetNode = document.getElementById('elem-id');//配置 dom 的哪些改变会触发回调函数，详细见下文表格。var mutationObserverInitConfig = &#123; attributes: true, childList: true, subtree: true &#125;;// dom 变化时触发的回调函数，传入 mutationsList：记录 dom 变化的对象数组。var callback = function(mutationsList) &#123; for(var mutation of mutationsList) &#123; console.log( 'dom 变化啦！'); youCoreFun(); &#125;&#125;;// 创建一个 MutationObserver 示例，传入回调函数var observer = new MutationObserver(callback);// 注册监控的节点、监控的事件observer.observe(targetNode, mutationObserverInitConfig);// 停止监控observer.disconnect(); MutationObserver 允许我们订阅某个dom元素的某些事件变化： 初始化12345var callback = function(mutationsList) &#123;// mutationsList:数组类型的通知队列，其元素 MutationRecord 记录触发变化的详细信息。// mutationsList：[MutationRecord,MutationRecord]&#125;;var observer = new MutationObserver(callback); MutationRecord 每次 dom 变动都会触发通知，合理利用 MutationRecord 进行条件判断，避免执行不必要的 callback 操作。| 属性 | 描述 ||— | — ||type|根据变动类型的不同，值可能性：attributes，characterData、childList|target|触发通知的DOM节点|addedNodes|被添加的节点|removedNodes|被删除的节点|previousSibling| 被添加或被删除的节点的前一个兄弟节点|nextSibling| 被添加或被删除的节点的后一个兄弟节点|attributeName|发生变更的属性的名称|attributeNamespace|发生变更的属性的命名空间|oldValue|果 type 为 characterData，则返回该节点变化之前的文本数据；如果 type为 childList，则返回 null 方法详解observe(dom,configObj)12345observer.observe(targetNode, &#123; attributes: true, childList: true, subtree: true&#125;); 调用 observe 后开始接收通知，触发初始化 MutationObserver 实例时传入的回调函数。 mutationObserverInit 字典MutationObserver 配置信息，observe 函数的第二个入参，对象类型。 属性 类型 描述 默认值 childList Boolean 观察子节点变动 false subtree Boolean 观察所有后代节点的变动 false attributes Boolean 观察属性的变动 false attributeFilter Array 属性过滤器，例如：传入[“status”]，仅在属性 status 变化时触发回调 无 attributeOldValue Boolean 是否记录 attributes 变动前的属性值 无 characterData Boolean 观察字符数据的变化 无 characterDataOldValue Boolean 是否记录 characterData 变动前的属性值 无 注意 childList 和 subtree 指定了监视范围（子节点或者所有后代节点），attributes 和 characterData 配置是否在监视范围内监控目标节点属性、文本的变化。 childList，attributes 或者 characterData 三个属性之中，至少有一个必须为 true，否则会抛出 TypeError 异常。 disconnect()1observer.disconnect(); 告诉观察者停止观察变动。 可以通过调用其observe()方法来重用观察者。所有已经检测到但是尚未向观察者报告的变动都会被丢弃。 takeRecords()1observer.takeRecords(); 除了被动等待变化事件通知，我们还可以使用 takeRecords 函数主动从 通知队列中拉取所有待处理的通知。 需要注意的是调用 takeRecords 函数后，通知队列为空，不会触发回调函数。 takeRecords例子 浏览器兼容性 不兼容的浏览器可以使用旧 API Mutation events 作为替代方案。 参考资料 张鑫旭-聊聊JS DOM变化的监听检测与应用 Santiago García da Rosa-JavaScript: MutationObserver MDN-MutationObserver JavaScript 标准参考教程-Mutation Observer API 逆葵-深入 MutationObserver","categories":[],"tags":[]},{"title":"Mock 能做什么？","slug":"Mock 能做什么？","date":"2021-04-13T00:20:22.322Z","updated":"2021-04-13T00:20:22.324Z","comments":true,"path":"Mock 能做什么？/","link":"","permalink":"http://scar.site/Mock%20%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"Mock 能做什么？1.API 没开发好，使用 Mock 快速对接在产品经理发布需求后，前后端同学先根据功能需求出一份 API 文档，然后再按照 API 文档并行开发。 不依赖后端提供数据的情况下，如何让前端独立于后端进行开发呢？ 使用 Mock,你可以在开发环境代码内置 Mock，拦截请求，模拟真实 API 返回。如果公司使用了接口管理平台，文档发布的时候可以还通过平台生成 Mock API 直接对接。 2.为测试提供数据使用Mock 假数据替代我们想控制但控制困难的部分 例如 某些 API 依赖其他 API 的返回值，使用 Mock 方便的对返回值进行改变，测试不同场景下 API 的表现。 某个 API 特别慢，可以暂时用 Mock 代替它，快速调通整个场景测试流程。 3.方便快速建立功能原型敏捷开发过程中，调整需求是很常见的。通过 Mock 可以快速建立功能原型，直观的看到业务逻辑，方便产品调整需求，还可以使用假数据对系统进行演示。 Mock 部署记录以下三种方案，各有千秋。 1.将 Mock 写到代码变量中，哪里需要写哪里例如 优点 成本低，使用简单，只需要学习 Mock.js 模板语法。 不受网络影响。 改动 Mock 能够快速看到效果。 缺点 Mock 代码与业务代码耦合高，上线容易遗漏测试代码，为代码偷偷埋下一颗地雷。 无法快速响应文档改动，保持 Mock 返回数据与文档一致。 只有前端开发人员能用到 Mock，无法与其他部门人员协同工作。 没有 API 请求，不够真实。 2. Mock.js 拦截请求使用 Mock.mock 函数拦截请求 1234567891011var data = Mock.mock(\"https://www.baidu.com\", &#123; \"string|1-10\": \"★\", //随机生成 1-10 个字符串\"★\"&#125;)var request = new XMLHttpRequest();request.open(\"GET\", \"https://www.baidu.com\", true);request.send();request.onreadystatechange = function () &#123; if (request.readyState === 4 &amp;&amp; request.status === 200) &#123; console.log(request.responseText) &#125;&#125; 控制台输出 优点 成本低，使用简单，学习 Mock.js 模板语法、 Mock.mock 函数。 不受网络影响。 改动 Mock 能够快速看到效果。 缺点 对于 RESTful 风格的 API，需要写正则匹配请求地址。 Mock 代码与业务代码仍存在耦合，可以独立一个 Mock 文件夹，上线构建时不打包进业务代码。 无法快速响应文档改动，保持 Mock返回数据与文档一致； API 请求被 Mock 拦截，没有实际发送，不够真实。 只有前端开发人员能用到 Mock，无法与其他部门人员协同工作。 3. Mock Server和实际请求 HTTP API 没有区别，API 的响应值不是真实从数据库获取的数据，而是 Mock 生成的假数据。 一般是后端人员维护 Mock Server，他们改动 API 的时候同步改动 mock，前端不用考虑 Mock，只需要变更请求地址。 优点 维护文档的人员可以维护 Mock，文档改动同时改动 Mock，响应迅速！ 协同方便，测试人员可以利用开发建立的 Mock 提前建立单元测试。 使用工具的话可以通过用户界面管理 Mock 数据。 缺点 需要花钱（部署服务器的钱或者 Sass 付费） 需要选择靠谱的工具，否则使用工具的提高的效率跟不上你帮工具找 Bug 的速率 额外管理 Mock Server，前端无法快速改变 Mock 值。 自己搭建针对各种语言的部署方案教程丰富，例子不举了，自个儿搜。 平台部署Eolinker 在线网站，无需部署。免费版本支持 3 人协作，超过 3 人需要开通付费版。 可以管理 API 文档，系统提供的 Mock 功能通过 API 文档返回值信息快速生成随机数据。支持设置触发条件（请求头、请求体），根据不同的触发条件得到不同的返回值。 Easy Mock 没使用过，支持在线（在线版本可能不够稳定），也支持本地部署。 Mock 数据生成规范可以通过两种方式告诉 Mock 如何生成数据，一种是自定义规则的数据模板，一种是占位符，提供一些常见的随机值，例如·图片、邮箱、人名等。 1.数据模板定义规范（Data Template Definition，DTD）先看一个示例，Mock.mock 函数根据相应的数据模板生成相应 JSON。 12345678910111213141516 Mock.mock(&#123; \"string|1-10\": \"★\",//随机生成 1-10 个字符串\"★\" \"string2|3\": \"★\",//固定生成 3 个字符串\"★\" \"number|+1\": 202,//每次请求自增 1,初始值为 202 \"number2|1-100.1-10\": 1,//生成一个浮点数，整数部分1-100，小数部分保留1-10 位。。 \"boolean|1-2\": true,//值为 true 的概率是 1/(1+2)，值为 false 的概率同样是 2/3。 \"regexp\": /[a-z][A-Z][0-9]/,//随机生成满足正则的字符串 \"object|2\": &#123; \"310000\": \"上海市\", \"320000\": \"江苏省\", \"440000\":\"广东省\" &#125;,//对象中随机选取 2 个属性，生成对象 \"array|1\": [ \"AMD\",\"CMD\"],//数组中随机选取 1 个元素，最终生成值 \"arrayRepeat|3\": [\"AMD\",\"CMD\"],//重复数组元素 3 次，最终生成数组 \"date\":\"@date\"//生成随机日期&#125;) 生成结果 12345678910111213141516 &#123; \"string\": \"★★\", \"string2\": \"★★★\", \"number\": 202, \"number2\": 71.73566, \"boolean\":true, \"regexp\": \"qS8\", \"absolutePath\": \"★★ demo\", \"object\": &#123; \"310000\": \"上海市\", \"440000\": \"广东省\" &#125;, \"array\": \"AMD\", \"arrayRepeat\": [\"AMD\",\"CMD\", \"AMD\",\"CMD\",AMD\",\"CMD\"], \"date\":\"1980-12-19\"&#125; 数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值： 12// '属性名|生成规则':属性值'name|rule': value 针对不同的属性值，生成规则的意义也不一样，有的生成规则是概率（Boolean），有的生成规则是重复。具体的意义可以查阅 Mock.js 官方文档 2.数据占位符定义规范（Data Placeholder Definition，DPD）占位符是 mock 提供一些常用的随机数据例如随机生成的图片、邮箱、人名等。 用法1: 直接使用12Mock.mock('@date')//1982-10-15Mock.Random.date()//1997-12-31 用法2: 在数据模板中使用12345678910Mock.mock(&#123; \"date\":\"@date\",//随机日期 \"float\":\"@float\",//随机浮点数 \"name\":\"xxxx\",//固定值 \"quoteStrin1\": \"@name\",//引用其他属性 \"user\": &#123; \"name\": \"demo\" &#125;,//固定值 \"quoteString\": \"@user/name\",//引用其他属性&#125;) 12345678910&#123; \"date\":\"2020-06-29\", \"float\":2202285915843574.5, \"name\":\"xxxx\", \"quoteStrin1\":\"xxxx\", \"user \":&#123; \"name\":\"demo\" &#125;, \"quoteString\":\"demo\"&#125; 需要注意，如果引用的属性名和 Mock 占位符名称一样（上面例子中的 quoteStrin1），引用值优先级比占位符高，所以最后 quoteStrin1 属性值与属性 name 的属性值一致,而不是占位符生成的值(Paul Miller)。 Mock 函数1.Mock.mock拦截请求，生成模拟数据 1234567891011var data = Mock.mock(\"https://www.baidu.com\", &#123; \"string|1-10\": \"★\", //随机生成 1-10 个字符串\"★\"&#125;)var request = new XMLHttpRequest();request.open(\"GET\", \"https://www.baidu.com\", true);request.send();request.onreadystatechange = function () &#123; if (request.readyState === 4 &amp;&amp; request.status === 200) &#123; console.log(request.responseText) &#125;&#125; 直接生成模拟数据 1234var data = Mock.mock(\"https://www.baidu.com\", &#123; \"string|1-10\": \"★\", //随机生成 1-10 个字符串\"★\"&#125;)//&#123;\"string\":\"★★\"&#125; 3.Mock.RandomMock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 提供的完整方法如下:|类型|方法|备注|—|—|—|Basic| boolean, natural, integer, float, character, string, rangeDate|date,time, datetime, nowImage| image, dataImage|生成图片地址Color| color,hex,rgb,rgba,hslText| paragraph, sentence, word, title, cparagraph, csentence, cword, ctitleName|first, last, name, cfirst, clast, cnameWeb|url, domain,protocol, email, ip, tldAddress| region,province,city,county,zipHelper|capitalize, upper, lower, pick, shuffle|方法，Mock.mock(‘@lower(“HELLO”)’)-&gt;helloMiscellaneous|uuid,guid, id,increment 还可以使用 Random.extend 拓展占位符，官网示例： 1234567891011121314Random.extend(&#123; constellation: function(date) &#123; var constellations = ['白羊座', '金牛座', '双子座', '巨蟹座', '狮子座', '处女座', '天秤座', '天蝎座', '射手座', '摩羯座', '水瓶座', '双鱼座'] return this.pick(constellations) &#125;&#125;)Random.constellation()// =&gt; \"水瓶座\"Mock.mock('@CONSTELLATION')// =&gt; \"天蝎座\"Mock.mock(&#123; constellation: '@CONSTELLATION'&#125;)// =&gt; &#123; constellation: \"射手座\" &#125; 参考资料 Mock.js 文档 No API? No Problem! Rapid Development via Mock APIs-Cory House 莫池宇-你是如何构建 Web 前端 Mock Server 的？","categories":[],"tags":[]},{"title":"JavaScript 日期操作","slug":"js-opr-date","date":"2020-07-13T12:46:25.000Z","updated":"2021-04-13T00:31:36.493Z","comments":true,"path":"js-opr-date/","link":"","permalink":"http://scar.site/js-opr-date/","excerpt":"平时对 Date 很多内容都一知半解，每次一用到 Date 就需要查资料，着实恼火。故此文记录关于 JS 日期操作那些我不知道的事。","text":"平时对 Date 很多内容都一知半解，每次一用到 Date 就需要查资料，着实恼火。故此文记录关于 JS 日期操作那些我不知道的事。 基础问题Date.prototype.getTime() 返回的数字是什么？官方对getTime 函数对定义是 The getTime() method returns the number of milliseconds* since the Unix Epoch getTime() 函数返回从 Unix Epoch 开始到当前 Date 所指时间经过的毫秒数。 Unix Epoch 是什么呢？ 1970年1月1日（UTC/GMT的午夜） 所以 getTime() 返回的数字是从 1970年1月1日0时0分0秒开始到当前 Date 对象所指时间所经过的毫秒数。 例如： getTime() 和你所在的时区也有关系，我国的标准时间是北京时间，在东八区，所以比英国格林威治时间（GMT）的 0 时区晚 8 个小时。所以我定义的 1970年1月1日使用 getTime 函数得到 -2880000,即 8 小时。 GMT 和 UTC 是什么，有什么区别？GMT（格林尼治标准时间） 和 UTC（协调世界时） 是计算世界时间的两种标准。 GMT 根据地球的自转和公转来计算时间，也就是太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间就是中午12点。UTC是根据原子钟来计算时间，目前世界上最精确的原子钟50亿年才会误差1秒。因为地球的自传正在缓速变慢，会导致 GMT 计算有误差，所以 UTC 比 GMT 更加精确。UTC 时间被认为能与GMT 时间互换，但 GMT 时间已不再被科学界所确定。 PS:两个都是 0 时区的时间，例如：UTC +8 = 北京时间。 Date.getMonth() 为什么要从 0 开始谁能想到这是 Java 埋的坑，因为 Javascript 的 Date 实现方案是 JDK1.0 的方案，所以坑也一样。Javascript 之父用一句 Make It Look Like Java 调侃了这个坑也告诉了我们答案。 问题来了，Java 获取月份为什么要从 0 开始呢？ 说法 1: 可能是因为旧的 C 语言日期 API 是这样的，那么旧的 C 语言日期 API 为什么是这样呢？…不套娃了。 说法 2:计算机里面所有东西都从 0 开始 说法 3:从 0 开始做月份计算更加容易 例如 12 月的下一个月份是 1 月，不过为了计算出 1 月你会做以下计算： 112 + 1 = 13 // 13 月是哪个月? 我们可以用 12 取余快速修复上面的问题 1(12 + 1) % 12 = 1 但是当遇到 11 月的时候… 1(11 + 1) % 12 = 0 // 0 月是哪个月? 您可以在添加月份之前先减去1，然后再进行取余运算，最后再加1，就可以修复上面的问题…也可以解决这个“基本问题”。 1((11 - 1 + 1) % 12) + 1 = 12 // 许多神奇的数字！ 现在我们来看看如果月份的数字是 0 - 11，会有什么问题？ 123456789101112(0 + 1) % 12 = 1 // February(1 + 1) % 12 = 2 // March(2 + 1) % 12 = 3 // April(3 + 1) % 12 = 4 // May(4 + 1) % 12 = 5 // June(5 + 1) % 12 = 6 // July(6 + 1) % 12 = 7 // August(7 + 1) % 12 = 8 // September(8 + 1) % 12 = 9 // October(9 + 1) % 12 = 10 // November(10 + 1) % 12 = 11 // December(11 + 1) % 12 = 0 // January 所有月份的表现一致，无需较复杂的解决方案。 时间戳是什么？常指 unix 时间戳，上文提到过：从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数。获取时间戳的代码： 1Math.round(new Date().getTime()/1000) 常用方法定义时间的方法传入时间格式的字符串123new Date('September 11, 1995 03:24:00')new Date('1995-09-11T03:24:00')new Date('Mon Sep 11 1995') 不同的浏览器实现有差异，强烈不建议使用字符串初始化/解析日期。建议使用传入数字初始化日期对象。相同的浏览器针对不同的定义方式也有些许差异。 例子1： 12new Date(Date.parse(\"Jul 8, 2005\"));//Fri Jul 08 2005 00:00:00 GMT+0800 (China Standard Time)new Date(Date.parse(\"2005-07-08\"));//Fri Jul 08 2005 08:00:00 GMT+0800 (China Standard Time) 例子2:在 2020年以前的，Firefox 和 Chrome 针对以下代码实现有差异。 123Date.parse('1970-01-01T00:00:00Z'); // Chrome: 0 FF: 0Date.parse('1970-01-01T00:00:00-0500'); // Chrome:18000000 FF: 18000000Date.parse('1970-01-01T00:00:00'); // Chrome: 0 FF: -28800000 传入多个时间单位的数字12new Date(1995, 8, 11)//注意，月份需要减 1，例如定义 9 月，第二个月份参数需要传 8new Date(1995, 8, 11, 3, 24, 0) 传入 Unix 时间戳1new Date(810761040000) //Mon Sep 11 1995 03:24:00 GMT+0800 (China Standard Time) 时间的加减法减法首先，需要将你的日期转化为 Date 对象，然后直接使用加减符号计算差。得到的结果是和或差的毫秒数，再将毫秒转化成你需要的格式。例如 2020-01-01 和 2020-01-02 差多久？ 1new Date(2020,0,2)-new Date(2020,0,1)//86400000[ms] 如果结果是要计算差多少天，即是 86400000 除以 1000得到秒数，再除以 60 得到分钟数，以此类推。 186400000/1000/60/60/24 //1 加法两个 Date 相减能得到毫秒，那理所当然地某个 Date 加上毫秒数就可以等于另一个日期了。例如 2020-01-01 加上 86400000 毫秒，就等于 2020-01-02No！No！No！ 12new Date(2020,0,1)+86400000 //Wed Jan 01 2020 00:00:00 GMT+0800 (China Standard Time)86400000 我还是太年轻了，跨类型的两个对象，强行加在一起，不甜。 1.转换成数字相加将 new Date(2020,0,1) 转换成毫秒，来到整形的世界，快乐地计算。 12(new Date(2020,0,1).getTime()+86400000) //Thu Jan 02 2020 00:00:00 GMT+0800 (China Standard Time) 2.使用 JS 内置方法加减年、月、日、时、分、秒。例如： 123var date=new Date(2020,0,1);date.setDate(date.getDate()+1)//date:Thu Jan 02 2020 00:00:00 GMT+0800 (China Standard Time) 不同的时间单位的加法使用的方法不同，可以根据下表选择对应的方法。 单位|获取时间|设置时间|例子||—|—|—|—||秒|getSeconds|setSeconds|date.setSeconds(date.getSeconds()+1)||分|getMinutes|setMinutes|date.setMinutes(date.getMinutes()+1)||时|getHours|setHours|date.setHours(date.getHours()+1)||日|getDate|setDate|date.setDate(date.getDate()+1)||周|setFullYear|getFullYear|date.setFullYear(date.getFullYear() + x)||月|getMonth|setMonth|date.setMonth(date.getMonth()+1)||年|setFullYear|getFullYear|date.setFullYear(date.getFullYear() + x)| 比较时间的大小获取毫秒数，进行数字大小的比较。 1new Date(2020,0,1).getTime()&gt;=new Date(2020,0,1).getTime() //true 获取不同格式的当前时间toString()12new Date().toString();//Fri Sep 18 2020 00:18:59 GMT+0800 (China Standard Time)\" toLocaleString()12new Date().toLocaleString();// 9/18/2020, 12:18:16 AM toUTCString()/toGMTString()123new Date().toUTCString();new Date().toGMTString();//Thu, 17 Sep 2020 16:10:04 GMT GMT 已经不被推荐使用了，原因在上文提到过：UTC 比 GMT 精确。 toISOString()12new Date().toISOString();//2020-09-17T16:20:06.419Z 返回 ISO 格式 (ISO 8601)的日期。 ISO 格式日期的规则是生成格式为 YYYY-MM-DDTHH:mm:ss.sssZ 或者 ±YYYYYY-MM-DDTHH:mm:ss.sssZ 的24 位到 27 位字符串。 YYYY-MM-DDTHH:mm:ss.sssZ 里面的 T 是分隔日期和时间的符号。 YYYY-MM-DDTHH:mm:ss.sssZ 里面的 Z 是时区的占位符，可以不写时区用 Z 代替是 0 时区，也可以使用 2020-09-17T00:20:06+08:00 代表东八区。 资料 MDN-Date 知乎-UTC和GMT什么关系？ 知乎-JavaScript中的Date对象取值month为什么是从0开始的？ stackoverflow-why-is-january-month-0-in-java-calendar","categories":[],"tags":[]}],"categories":[],"tags":[]}